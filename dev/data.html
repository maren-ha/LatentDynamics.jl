<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data processing · LatentDynamics.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">LatentDynamics.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="data.html">Data processing</a><ul class="internal"><li><a class="tocitem" href="#SMArtCARE-data"><span>SMArtCARE data</span></a></li><li><a class="tocitem" href="#Simulated-data"><span>Simulated data</span></a></li></ul></li><li><a class="tocitem" href="dynamics.html">Dynamic model</a></li><li><a class="tocitem" href="vae.html">VAE model</a></li><li><a class="tocitem" href="evaluation.html">Evaluation</a></li><li><a class="tocitem" href="plotting.html">Plotting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="data.html">Data processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="data.html">Data processing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maren-ha/LatentDynamics.jl/blob/main/docs/src/data.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-processing"><a class="docs-heading-anchor" href="#Data-processing">Data processing</a><a id="Data-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-processing" title="Permalink"></a></h1><p>In the manuscript, we have used data from the SMArtCARE registry on patients with SMA. As the data cannot be made publicly available, we provide functions for simulating data with a similar structure.</p><h2 id="SMArtCARE-data"><a class="docs-heading-anchor" href="#SMArtCARE-data">SMArtCARE data</a><a id="SMArtCARE-data-1"></a><a class="docs-heading-anchor-permalink" href="#SMArtCARE-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.SMATestData" href="#LatentDynamics.SMATestData"><code>LatentDynamics.SMATestData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SMATestData</code></pre><p>Struct to serve as a container for the SMArtCARE data, consisting of the following fields: </p><ul><li><code>test</code>: name of the motor function test for which the data is collected</li><li><code>xs</code>: vector of matrices (n<em>items x n</em>timepoints) of the item scores across time of           the chosen test for each patient</li><li><code>xs_baseline</code>: vector of vectors of baseline variable measurements for each patient</li><li><code>tvals</code>: vector of vectors of follow-up time points for each patient</li><li><code>ids</code>: vector of patient IDs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/PreprocessingSMArtCARE.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.get_SMArtCARE_data" href="#LatentDynamics.get_SMArtCARE_data"><code>LatentDynamics.get_SMArtCARE_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_SMArtCARE_data(test::String, baseline_df, timedepend_df; extended_output::Bool=false)</code></pre><p>Function to preprocess the SMArtCARE data for a specific test. The function returns an <code>SMATestData</code> struct with the extracted information      on time-dependent and baseline variables, follow-up time points and IDs of all patients for whom the chosen test was conducted.</p><p>From the provided input dataframes, the function first filters the time-dependent dataframe for patients that have the selected test conducted.  The dataframe is then subset to the variables of the items of the specific test.  The baseline dataframe is subset to the same patients.  For each patient, outlier time points are filtered out.  An outlier is classified as a time point where the difference to the previous time point is larger than 2 times the  interquartile range of all difference between subsequent time points for that patient. Additionally, the variance of the sum score of the test is calculated, to allow for potential further subsequent filtering.</p><p><strong>Arguments</strong></p><ul><li><code>test</code>: name of the motor function test for which the data is collected</li><li><code>baseline_df</code>: DataFrame containing the baseline variables for all patients</li><li><code>timedepend_df</code>: DataFrame containing the time-dependent variables for all patients</li><li><code>extended_output</code>: if <code>true</code>, the function also returns the calculated variances of the sumscore for each patient    and the time point masks that show which time points where filtered out for each patient. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/PreprocessingSMArtCARE.jl#L35-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.recode_SMArtCARE_data" href="#LatentDynamics.recode_SMArtCARE_data"><code>LatentDynamics.recode_SMArtCARE_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recode_SMArtCARE_data(testdata::SMATestData)</code></pre><p>Recodes the time-dependent item values in an <code>SMATestData</code> struct to be between 0 and 1.      Original item levels are integers between 0 and 2 for all items except item a, which has values between     0 and 6.      Each item is separately mapped to numbers between 0 and 1 and the values are subsequently logit-transformed.      A new <code>SMATestData</code> struct is returned, where the recoded values are stored in the <code>xs</code> field. </p><p><strong>Arguments</strong></p><ul><li><code>testdata::SMATestData</code>: the test data to be recoded</li><li><code>recoding_dict</code>: Dictionary specifying the numbers item levels should be recoded to for all items except a;    default is Dict(0 =&gt; 0.1, 1 =&gt; 0.5, 2 =&gt; 0.9) and this is what has been used for all experiments. </li><li><code>recoding_dict_itema</code>: Dictionary specifying the numbers item levels should be recoded to for item a;    default is Dict(0 =&gt; 0.1, 1 =&gt; 0.2, 2 =&gt; 0.3, 3 =&gt; 0.5, 4 =&gt; 0.7, 5 =&gt; 0.8, 6 =&gt; 0.9) and this is what    has been used for all experiments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/PreprocessingSMArtCARE.jl#L167-L183">source</a></section></article><h2 id="Simulated-data"><a class="docs-heading-anchor" href="#Simulated-data">Simulated data</a><a id="Simulated-data-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.simdata" href="#LatentDynamics.simdata"><code>LatentDynamics.simdata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct simdata</code></pre><p>Struct to serve as a container for simulated data, consisting of the following fields: </p><ul><li><code>xs</code>: vector of matrices (n<em>variables x n</em>timepoints) of simulated values    of the different variables across time for each patient</li><li><code>xs_baseline</code>: vector of vectors of baseline variable measurements for each patient</li><li><code>tvals</code>: vector of vectors of follow-up time points for each patient</li><li><code>group1</code>: vector of indices of patients belonging to group 1</li><li><code>group2</code>: vector of indices of patients belonging to group 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/SimulateData.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.generate_xs" href="#LatentDynamics.generate_xs"><code>LatentDynamics.generate_xs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_xs(n, p, true_u0, sol_group1, sol_group2; 
    t_start=1.5, t_end=10, maxntps = 10, dt=0.1, σ_var=0.1, σ_ind=0.5)</code></pre><p>Generates simulated data by sampling <code>n</code> observations of <code>p</code> variables at between 1 and <code>maxntps</code> timepoints for each individual      by randomly selecting one of the true underlying ODE solutions given by <code>sol_group1</code> and <code>sol_group2</code>, taking its values      at a randomly sampled number between 1 and <code>maxntps</code> of randomly sampled time points and adding variable-specific      and individual-specific errors to the values of the true trajectories, where the variance of the error terms is controlled by      <code>σ_var</code> and <code>σ_ind</code>. </p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: number of individuals to simulate </li><li><code>p</code>: number of time-dependent variables to simulate - should be divisible by the number of the true underlying    trajectory dimensions, so the first (p/n<em>true</em>dimensions) variables can be noisy versions of the first dimension of    the true dynamics, and so on. </li><li><code>true_u0</code>: vector stating the initial condition of the ground-truth underlying ODE systems from which to simulate the data </li><li><code>sol_group1</code>: true ODE solution of the first group </li><li><code>sol_group2</code>: true ODE solution of the second group </li></ul><p><strong>Optional keyword arguments:</strong></p><ul><li><code>t_start</code>: Earliest time point possible for follow-up measurements, start of the interval from which to sample the    subsequent measurement time point(s). Default = 1.5</li><li><code>t_end</code>: Latest time point possible for follow-up measurements, end of the interval from which to sample the    subsequent measurement time point(s). Default = 10</li><li><code>maxntps</code>: maximum number of time points per individual after the baseline timepoint. Default = 1</li><li><code>dt</code>: time steps at which to solve the ODE. Needed to ensure correct array sizes. Default = 0.1</li><li><code>σ_var</code>: variance with which to sample the variable-specific error terms. Default = 0.1</li><li><code>σ_ind</code>: variance with which to sample the individual-specific error terms. Default = 0.5</li></ul><p><strong>Returns:</strong></p><ul><li><code>xs</code>: vector of length <code>n</code> = n<em>individuals, where the <code>i</code>th element is a (n</em>vars=p x n_timepoints) matrix    containing the simulated values of the time-dependent variables of the <code>i</code>th individual in the dataset</li><li><code>tvals</code>: vector of length <code>n</code> = n<em>individuals, where the <code>i</code>th element is a vector of length 1 (or more generally n</em>timepoints_i)   containing the simulated time point of the <code>i</code>th individual&#39;s second measurement (or all the timepoints after the baseline visit)</li><li><code>group1</code>: indices of all individuals in group1 </li><li><code>group2</code>: indices of all individuals in group1 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/SimulateData.jl#L20-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.generate_baseline-NTuple{4, Any}" href="#LatentDynamics.generate_baseline-NTuple{4, Any}"><code>LatentDynamics.generate_baseline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_baseline(n, q, q_info, group1; σ_info=1, σ_noise=1)</code></pre><p>Generates simulated baseline data by sampling <code>n</code> observations of <code>q</code> baseline variables, of which only the first <code>q_info</code>     are informative, and the other ones are just pure noise variables, based on the group membership information.      This information is given by <code>group1</code>, the indices of all individuals in group1, based on which the other indices in      group 2 can be inferred, since union(group1, group2) = {1,...,n}.      Baseline measurements are simulated by encoding group membership as 1 or -1 and drawing from N(0,σ<em>info) or N(1, σ</em>info),     repectively. For the noise variables, data are simulated by drawing from N(0, σ_noise). </p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: number of individuals to simulate </li><li><code>q</code>: number of baseline variables to simulate </li><li><code>q_info</code>: number of informative baseline variables. </li><li><code>group1</code>: indices of all individuals in group1 - since [group1, group2] = {1,...,n}, the <code>group2</code> indices can be inferred from that</li></ul><p><strong>Optional keyword arguments:</strong></p><ul><li><code>σ_info</code>: variance with which to sample from the group membership information in the informative baseline variables terms. Default = 1</li><li><code>σ_noise</code>: variance with which to sample the noise baseline variables terms. Default = 1</li></ul><p><strong>Returns:</strong></p><ul><li><code>x_params</code>: vector of length <code>n</code> = n<em>individuals, where the <code>i</code>th  element is a vector of length (n</em>baselinevars=q)   containing the baseline information for the <code>i</code>th individual in the dataset </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/SimulateData.jl#L111-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatentDynamics.generate_baseline-NTuple{6, Any}" href="#LatentDynamics.generate_baseline-NTuple{6, Any}"><code>LatentDynamics.generate_baseline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_baseline(n, q, q_info, group1, true_odeparams_group1, true_odeparams_group2; σ_info=0.1, σ_noise=0.1)</code></pre><p>Generates simulated baseline data by sampling <code>n</code> observations of <code>q</code> baseline variables, of which only the first <code>q_info</code>     are informative, and the other ones are just pure noise variables, based on the true ODE parameters passed as      <code>true_odeparams_group1</code> and <code>true_odeparams_group2</code>.      Baseline measurements are simulated by sampling from the true parameters with a standard deviation of σ<em>info.      For the noise variables, data are simulated by drawing from N(0, σ</em>noise). </p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: number of individuals to simulate</li><li><code>q</code>: number of baseline variables to simulate </li><li><code>q_info</code>: number of informative baseline variables. </li><li><code>group1</code>: indices of all individuals in group1 - since [group1, group2] = {1,...,n}, the <code>group2</code> indices can be inferred from that</li></ul><p><strong>Optional keyword arguments:</strong></p><ul><li><code>σ_info</code>: variance with which to sample from the group membership information in the informative baseline variables terms. Default = 0.1. </li><li><code>σ_noise</code>: variance with which to sample the noise baseline variables terms. Default = 0.1. </li></ul><p><strong>Returns:</strong></p><ul><li><code>x_params</code>: vector of length <code>n</code> = n<em>individuals, where the <code>i</code>th  element is a vector of length (n</em>baselinevars=q)   containing the baseline information for the <code>i</code>th individual in the dataset </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/LatentDynamics.jl/blob/1a9c188ea2b91fd1eb1ebeb61b5cacea4f1afb7c/src/SimulateData.jl#L147-L169">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="dynamics.html">Dynamic model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 18 June 2023 18:31">Sunday 18 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"vae.html#ODE-VAE-model","page":"VAE model","title":"ODE-VAE model","text":"","category":"section"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"We integrate the ODE-based dynamic model in the latent space of a VAE for flexible non-linear dimension reduction, reflecting the assumption of a lower-dimensional underlying dynamic process driving the observed measurements. The following functions are used to define, construct and train an ODE-VAE model. ","category":"page"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"To jointly optimize all components, i.e., the dynamic model and the VAE for dimension reduction, and the ODE-net for obtaining person-specific ODE parameters, we implement a joint loss function that incorporates all components and optimize it by stochastic gradient descent. This requires to differentiate through our ODE estimator and the calculation of time-dependent inverse-variance weights. Here, we exploit the flexible automatic differentiation system from Zygote.jl to simultaneously obtain gradients with respect to the VAE encoder and decoder parameters and the individual-specific dynamic model parameters in a straightforward way that requires minimal code adaptation. Zygote is specifically useful for that because of its very powerful source-to-source differentiation, that allows for differentiate through arbitrary Julia code, including the ODE solvers, user-defined structs, loops and recursion without any code refactoring or adaptation. For details, check out, e.g., Innes et al. (2019).","category":"page"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"As a result of this joint optimization, the components can influence each other, such that a latent representation can be found that is automatically adapted to the underlying dynamics and the ODE system structures and regularizes the representation. ","category":"page"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"As our ODEs have analytical solutions, differentiation through the latent dynamics estimator does not require backpropagating gradients through a numerical ODE solving step. However, differentiable programming also allows for differentiating through ODE solvers in each loss function gradient update, which can be realized efficiently, e.g., using the adjoint sensitivity method.","category":"page"},{"location":"vae.html#Defining-the-model","page":"VAE model","title":"Defining the model","text":"","category":"section"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"odevae","category":"page"},{"location":"vae.html#LatentDynamics.odevae","page":"VAE model","title":"LatentDynamics.odevae","text":"odevae\n\nStruct for an ODE-VAE model, with the following fields:\n\np: number of VAE input dimensions, i.e., number of time-dependent variables\nq: number of input dimensions for the baseline neural net, i.e., number of baseline variables\nzdim: number of latent dimensions\nODEnet: neural net to map baseline variables to individual-specific ODE parameters    (number of ODE parameters depends on the ODE system specified by the dynamics function)\nencoder: neural net to map input data to latent space\nencodedμ: neural net layer parameterizing the mean of the latent space\nencodedlogσ: neural net layer parameterizing the log variance of the latent space\ndecoder: neural net to map latent variable to reconstructed input data\ndecodedμ: neural net layer parameterizing the mean of the reconstructed input data\ndecodedlogσ: neural net layer parameterizing the log variance of the reconstructed input data\ndynamics: one of params_fullinhomogeneous, params_offdiagonalinhomogeneous,    params_diagonalinhomogeneous, params_driftonly, params_fullhomogeneous,    params_offdiagonalhomogeneous, params_diagonalhomogeneous: function to map a parameter vector   (=the output of the ODEnet) to the system matrix and constant vector of the ODE system\n\n\n\n\n\n","category":"type"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"odevae(modelargs::ModelArgs)","category":"page"},{"location":"vae.html#LatentDynamics.odevae-Tuple{ModelArgs}","page":"VAE model","title":"LatentDynamics.odevae","text":"odevae(modelargs::ModelArgs)\n\nFunction to initialize the ODE-VAE model according to the arguments passed in modelargs.\n\nReturns an odevae model.\n\n\n\n\n\n","category":"method"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"ModelArgs","category":"page"},{"location":"vae.html#LatentDynamics.ModelArgs","page":"VAE model","title":"LatentDynamics.ModelArgs","text":"ModelArgs\n\nStruct to store model arguments, can be constructed with keyword arguments to set the following fields:\n\np: number of VAE input dimensions, i.e., number of time-dependent variables\nq: number of input dimensions for the baseline neural net, i.e., number of baseline variables\nzdim: number of latent dimensions\ndynamics: one of params_fullinhomogeneous, params_offdiagonalinhomogeneous,    params_diagonalinhomogeneous, params_driftonly, params_fullhomogeneous,    params_offdiagonalhomogeneous, params_diagonalhomogeneous: function to map a parameter vector   (=the output of the ODEnet) to the system matrix and constant vector of the ODE system\nseed: random seed for reproducibility\nbottleneck: whether to use a bottleneck layer in the ODEnet    to reduce the number of effective parameters for higher-dimensional systems\ninit_scaled: whether to initialize the ODEnet with scaled weights\nscale_sigmoid: scaling factor for the sigmoid function used to shift the ODE parameters    to a sensible range, acting as a prior\nadd_diagonal: whether to add a diagonal transformation to output of the ODEnet to add   flexibility after the sigmoid transformation\n\n\n\n\n\n","category":"type"},{"location":"vae.html#Training-the-model","page":"VAE model","title":"Training the model","text":"","category":"section"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"LossArgs","category":"page"},{"location":"vae.html#LatentDynamics.LossArgs","page":"VAE model","title":"LatentDynamics.LossArgs","text":"LossArgs\n\nStruct to store loss arguments, can be constructed with keyword arguments to set the following fields:\n\nλ_μpenalty: weight for the penalty that encourages consistency of the mean before and after solving the ODEs\nλ_variancepenalty: weight for the penalty on the variance of the ODE estimator\nvariancepenaltytype: one of :ratio_sum, :sum_ratio, :log_diff:    type of penalty on the variance of the ODE estimator\nvariancepenaltyoffset: offset used in the penalty on the variance of the latent space\nfirstonly: whether to use only the first time point for solving the ODE (if false,    an ODE is solved with each time point as initial condition and the individual solutions are averaged)\nweighting: whether to calculate inverse-variance weights for the contribution of other time points    in the ODE trajectory estimator or use just equal weights for all ODE solutions\nskipt0: whether to skip the first time point in the ODE estimator    (to prevent the model from using just the initial condition and pushing the weights of all other solutions to zero)\n\n\n\n\n\n","category":"type"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"loss","category":"page"},{"location":"vae.html#LatentDynamics.loss","page":"VAE model","title":"LatentDynamics.loss","text":"loss(X, Y, t, m::odevae; args::LossArgs)\n\nCompute the loss of the ODE-VAE model m on a batch of data, consisting of      time-dependent variables X, baseline variables Y and time point t. \n\nDetails of the loss function behaviour, including additional penalties, are controlled by the      keyword arguments args of type LossArgs, see ?LossArgs for details.\n\nReturns the mean ELBO, where the ODE estimator of the underlying trajectory is used to decode the latent      value at the time points t and obtain a reconstruction according to these smooth latent dynamics      as specified by the ODE system.\n\n\n\n\n\n","category":"function"},{"location":"vae.html","page":"VAE model","title":"VAE model","text":"train_model!","category":"page"},{"location":"vae.html#LatentDynamics.train_model!","page":"VAE model","title":"LatentDynamics.train_model!","text":"train_model!(m::odevae, \n    xs, xs_baseline, tvals, \n    lr, epochs, args::LossArgs; \n    selected_ids=nothing, \n    verbose::Bool=true, \n    plotting::Bool=true\n    )\n\nTrain the ODE-VAE model m on a dataset of time-dependent variables xs,      baseline variables xs_baseline and time points tvals. The structure of these      is assumed to be as in the SMATestData and simdata structs. \n\nArguments\n\nm: the ODE-VAE model to train\nxs: a vector of matrices of time-dependent variables for each patient\nxs_baseline: a vector of vectors of baseline variables for each patient\ntvals: a vector of vectors of time points for each patient\nlr: the learning rate of the ADAM optimizer\nepochs: the number of epochs to train for\nargs: arguments controlling the loss function behaviour, see ?LossArgs for details\nselected_ids: the IDs of the patients to plot during training to monitor progress,   if nothing (default) then 12 random IDs are selected\nverbose: whether to print the epoch and loss value during training\nplotting: whether to visualize the learnt latent trajectories of selected patients    (those with the selected_ids)\n\nReturns\n\nm: the trained ODE-VAE model\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#Dynamic-model","page":"Dynamic model","title":"Dynamic model","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"We use a dynamic model based on ODEs, fitted in a statistical framework. Specifically, we solve multiple ODEs, using each observed value as the initial value and averaging the solutions using time-dependent inverse-variance weights. We thus obtain to obtain an unbiased minimum variance estimator of the true underlying dynamics. With this approach, we reduce dependence on the initial condition and increase robustness to noise, yet maintain a local perspective and mechanistic interpretation. ","category":"page"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"For modeling with a larger number of variables, we integrate the dynamic model in the latent space of a VAE for flexible non-linear dimension reduction, reflecting the assumption of a lower-dimensional underlying dynamic process driving the observed measurements. ","category":"page"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"generalsolution(t, x0::Vector{Float32}, A::Matrix{Float32}, c::Vector{Float32}) ","category":"page"},{"location":"dynamics.html#LatentDynamics.generalsolution-Tuple{Any, Vector{Float32}, Matrix{Float32}, Vector{Float32}}","page":"Dynamic model","title":"LatentDynamics.generalsolution","text":"generalsolution(t, x0::Vector{Float32}, A::Matrix{Float32}, c::Vector{Float32})\n\nCalculates the analytical solution of a linear system of ODEs with constant coefficients      at a time point t, for a system matrix A, a constant vector c and an initial value x0.\n\nReturns the solution x(t) and the matrix exponential e^{At}.\n\n\n\n\n\n","category":"method"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"generalsolution(t, x0::Vector{Float32}, c::Vector{Float32}) ","category":"page"},{"location":"dynamics.html#LatentDynamics.generalsolution-Tuple{Any, Vector{Float32}, Vector{Float32}}","page":"Dynamic model","title":"LatentDynamics.generalsolution","text":"generalsolution(t, x0::Vector{Float32}, c::Vector{Float32})\n\nCalculates the analytical solution of a constant system of ODEs at a time point t,      for a constant vector c and an initial value x0.\n\nReturns the solution x(t) and the matrix exponential e^{At} = 1.0.\n\n\n\n\n\n","category":"method"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"params_fullinhomogeneous","category":"page"},{"location":"dynamics.html#LatentDynamics.params_fullinhomogeneous","page":"Dynamic model","title":"LatentDynamics.params_fullinhomogeneous","text":"params_fullinhomogeneous(p::Vector{Float32})\n\nReturns the system matrix A and the constant vector c of a 2D inhomogeneous linear system      with 6 parameters specified by the input vector p = [a11, a12, a21, a22, c1, c2].\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"params_offdiagonalinhomogeneous","category":"page"},{"location":"dynamics.html#LatentDynamics.params_offdiagonalinhomogeneous","page":"Dynamic model","title":"LatentDynamics.params_offdiagonalinhomogeneous","text":"params_offdiagonalinhomogeneous(p::Vector{Float32})\n\nReturns the system matrix A and the constant vector c of a 2D inhomogeneous linear system where      the system matrix has only off-diagonal elements (i.e., diagonal entries are zero),      specified by the input vector p = [a12, a21, c1, c2].\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"params_diagonalinhomogeneous","category":"page"},{"location":"dynamics.html#LatentDynamics.params_diagonalinhomogeneous","page":"Dynamic model","title":"LatentDynamics.params_diagonalinhomogeneous","text":"params_diagonalinhomogeneous(p::Vector{Float32})\n\nReturns the system matrix A and the constant vector c of a 2D inhomogeneous linear system where     the system matrix is diagonal, specified by the input vector p = [a11, a22, c1, c2].\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"params_fullhomogeneous","category":"page"},{"location":"dynamics.html#LatentDynamics.params_fullhomogeneous","page":"Dynamic model","title":"LatentDynamics.params_fullhomogeneous","text":"params_fullhomogeneous(p::Vector{Float32})\n\nReturns the system matrix A and the constant vector c of a 2D homogeneous linear system     with 4 parameters specified by the input vector p = [a11, a12, a21, a22], and c = [0, 0].\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"params_diagonalhomogeneous","category":"page"},{"location":"dynamics.html#LatentDynamics.params_diagonalhomogeneous","page":"Dynamic model","title":"LatentDynamics.params_diagonalhomogeneous","text":"params_offdiagonalhomogeneous(p::Vector{Float32})\n\nReturns the system matrix A and the constant vector c of a 2D homogeneous linear system where     the system matrix is diagonal, specified by the input vector p = [a11, a22], and c = [0, 0].\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html","page":"Dynamic model","title":"Dynamic model","text":"params_driftonly","category":"page"},{"location":"dynamics.html#LatentDynamics.params_driftonly","page":"Dynamic model","title":"LatentDynamics.params_driftonly","text":"params_driftonly(p::Vector{Float32})\n\nReturns the constant vector c of a 2D inhomogeneous linear system where     the system matrix is zero, specified by the input vector p = [c1, c2].\n\n\n\n\n\n","category":"function"},{"location":"data.html#Data-processing","page":"Data processing","title":"Data processing","text":"","category":"section"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"In the manuscript, we have used data from the SMArtCARE registry on patients with SMA. As the data cannot be made publicly available, we provide functions for simulating data with a similar structure.","category":"page"},{"location":"data.html#SMArtCARE-data","page":"Data processing","title":"SMArtCARE data","text":"","category":"section"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"SMATestData","category":"page"},{"location":"data.html#LatentDynamics.SMATestData","page":"Data processing","title":"LatentDynamics.SMATestData","text":"mutable struct SMATestData\n\nStruct to serve as a container for the SMArtCARE data, consisting of the following fields: \n\ntest: name of the motor function test for which the data is collected\nxs: vector of matrices (nitems x ntimepoints) of the item scores across time of           the chosen test for each patient\nxs_baseline: vector of vectors of baseline variable measurements for each patient\ntvals: vector of vectors of follow-up time points for each patient\nids: vector of patient IDs\n\n\n\n\n\n","category":"type"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"get_SMArtCARE_data","category":"page"},{"location":"data.html#LatentDynamics.get_SMArtCARE_data","page":"Data processing","title":"LatentDynamics.get_SMArtCARE_data","text":"get_SMArtCARE_data(test::String, baseline_df, timedepend_df; extended_output::Bool=false)\n\nFunction to preprocess the SMArtCARE data for a specific test. The function returns an SMATestData struct with the extracted information      on time-dependent and baseline variables, follow-up time points and IDs of all patients for whom the chosen test was conducted.\n\nFrom the provided input dataframes, the function first filters the time-dependent dataframe for patients that have the selected test conducted.  The dataframe is then subset to the variables of the items of the specific test.  The baseline dataframe is subset to the same patients.  For each patient, outlier time points are filtered out.  An outlier is classified as a time point where the difference to the previous time point is larger than 2 times the  interquartile range of all difference between subsequent time points for that patient. Additionally, the variance of the sum score of the test is calculated, to allow for potential further subsequent filtering.\n\nArguments\n\ntest: name of the motor function test for which the data is collected\nbaseline_df: DataFrame containing the baseline variables for all patients\ntimedepend_df: DataFrame containing the time-dependent variables for all patients\nextended_output: if true, the function also returns the calculated variances of the sumscore for each patient    and the time point masks that show which time points where filtered out for each patient. \n\n\n\n\n\n","category":"function"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"recode_SMArtCARE_data","category":"page"},{"location":"data.html#LatentDynamics.recode_SMArtCARE_data","page":"Data processing","title":"LatentDynamics.recode_SMArtCARE_data","text":"recode_SMArtCARE_data(testdata::SMATestData)\n\nRecodes the time-dependent item values in an SMATestData struct to be between 0 and 1.      Original item levels are integers between 0 and 2 for all items except item a, which has values between     0 and 6.      Each item is separately mapped to numbers between 0 and 1 and the values are subsequently logit-transformed.      A new SMATestData struct is returned, where the recoded values are stored in the xs field. \n\nArguments\n\ntestdata::SMATestData: the test data to be recoded\nrecoding_dict: Dictionary specifying the numbers item levels should be recoded to for all items except a;    default is Dict(0 => 0.1, 1 => 0.5, 2 => 0.9) and this is what has been used for all experiments. \nrecoding_dict_itema: Dictionary specifying the numbers item levels should be recoded to for item a;    default is Dict(0 => 0.1, 1 => 0.2, 2 => 0.3, 3 => 0.5, 4 => 0.7, 5 => 0.8, 6 => 0.9) and this is what    has been used for all experiments.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Simulated-data","page":"Data processing","title":"Simulated data","text":"","category":"section"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"simdata","category":"page"},{"location":"data.html#LatentDynamics.simdata","page":"Data processing","title":"LatentDynamics.simdata","text":"mutable struct simdata\n\nStruct to serve as a container for simulated data, consisting of the following fields: \n\nxs: vector of matrices (nvariables x ntimepoints) of simulated values    of the different variables across time for each patient\nxs_baseline: vector of vectors of baseline variable measurements for each patient\ntvals: vector of vectors of follow-up time points for each patient\ngroup1: vector of indices of patients belonging to group 1\ngroup2: vector of indices of patients belonging to group 2\n\n\n\n\n\n","category":"type"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"generate_xs","category":"page"},{"location":"data.html#LatentDynamics.generate_xs","page":"Data processing","title":"LatentDynamics.generate_xs","text":"generate_xs(n, p, true_u0, sol_group1, sol_group2; \n    t_start=1.5, t_end=10, maxntps = 10, dt=0.1, σ_var=0.1, σ_ind=0.5)\n\nGenerates simulated data by sampling n observations of p variables at between 1 and maxntps timepoints for each individual      by randomly selecting one of the true underlying ODE solutions given by sol_group1 and sol_group2, taking its values      at a randomly sampled number between 1 and maxntps of randomly sampled time points and adding variable-specific      and individual-specific errors to the values of the true trajectories, where the variance of the error terms is controlled by      σ_var and σ_ind. \n\nArguments:\n\nn: number of individuals to simulate \np: number of time-dependent variables to simulate - should be divisible by the number of the true underlying    trajectory dimensions, so the first (p/ntruedimensions) variables can be noisy versions of the first dimension of    the true dynamics, and so on. \ntrue_u0: vector stating the initial condition of the ground-truth underlying ODE systems from which to simulate the data \nsol_group1: true ODE solution of the first group \nsol_group2: true ODE solution of the second group \n\nOptional keyword arguments:\n\nt_start: Earliest time point possible for follow-up measurements, start of the interval from which to sample the    subsequent measurement time point(s). Default = 1.5\nt_end: Latest time point possible for follow-up measurements, end of the interval from which to sample the    subsequent measurement time point(s). Default = 10\nmaxntps: maximum number of time points per individual after the baseline timepoint. Default = 1\ndt: time steps at which to solve the ODE. Needed to ensure correct array sizes. Default = 0.1\nσ_var: variance with which to sample the variable-specific error terms. Default = 0.1\nσ_ind: variance with which to sample the individual-specific error terms. Default = 0.5\n\nReturns:\n\nxs: vector of length n = nindividuals, where the ith element is a (nvars=p x n_timepoints) matrix    containing the simulated values of the time-dependent variables of the ith individual in the dataset\ntvals: vector of length n = nindividuals, where the ith element is a vector of length 1 (or more generally ntimepoints_i)   containing the simulated time point of the ith individual's second measurement (or all the timepoints after the baseline visit)\ngroup1: indices of all individuals in group1 \ngroup2: indices of all individuals in group1 \n\n\n\n\n\n","category":"function"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"generate_baseline(n, q, q_info, group1; σ_info=1.0f0, σ_noise=1.0f0)","category":"page"},{"location":"data.html#LatentDynamics.generate_baseline-NTuple{4, Any}","page":"Data processing","title":"LatentDynamics.generate_baseline","text":"generate_baseline(n, q, q_info, group1; σ_info=1, σ_noise=1)\n\nGenerates simulated baseline data by sampling n observations of q baseline variables, of which only the first q_info     are informative, and the other ones are just pure noise variables, based on the group membership information.      This information is given by group1, the indices of all individuals in group1, based on which the other indices in      group 2 can be inferred, since union(group1, group2) = {1,...,n}.      Baseline measurements are simulated by encoding group membership as 1 or -1 and drawing from N(0,σinfo) or N(1, σinfo),     repectively. For the noise variables, data are simulated by drawing from N(0, σ_noise). \n\nArguments:\n\nn: number of individuals to simulate \nq: number of baseline variables to simulate \nq_info: number of informative baseline variables. \ngroup1: indices of all individuals in group1 - since [group1, group2] = {1,...,n}, the group2 indices can be inferred from that\n\nOptional keyword arguments:\n\nσ_info: variance with which to sample from the group membership information in the informative baseline variables terms. Default = 1\nσ_noise: variance with which to sample the noise baseline variables terms. Default = 1\n\nReturns:\n\nx_params: vector of length n = nindividuals, where the ith  element is a vector of length (nbaselinevars=q)   containing the baseline information for the ith individual in the dataset \n\n\n\n\n\n","category":"method"},{"location":"data.html","page":"Data processing","title":"Data processing","text":"generate_baseline(n, q, q_info, group1, trueparams_group1, trueparams_group2; \n    σ_info=0.1f0, σ_noise=0.1f0)","category":"page"},{"location":"data.html#LatentDynamics.generate_baseline-NTuple{6, Any}","page":"Data processing","title":"LatentDynamics.generate_baseline","text":"generate_baseline(n, q, q_info, group1, true_odeparams_group1, true_odeparams_group2; σ_info=0.1, σ_noise=0.1)\n\nGenerates simulated baseline data by sampling n observations of q baseline variables, of which only the first q_info     are informative, and the other ones are just pure noise variables, based on the true ODE parameters passed as      true_odeparams_group1 and true_odeparams_group2.      Baseline measurements are simulated by sampling from the true parameters with a standard deviation of σinfo.      For the noise variables, data are simulated by drawing from N(0, σnoise). \n\nArguments:\n\nn: number of individuals to simulate\nq: number of baseline variables to simulate \nq_info: number of informative baseline variables. \ngroup1: indices of all individuals in group1 - since [group1, group2] = {1,...,n}, the group2 indices can be inferred from that\n\nOptional keyword arguments:\n\nσ_info: variance with which to sample from the group membership information in the informative baseline variables terms. Default = 0.1. \nσ_noise: variance with which to sample the noise baseline variables terms. Default = 0.1. \n\nReturns:\n\nx_params: vector of length n = nindividuals, where the ith  element is a vector of length (nbaselinevars=q)   containing the baseline information for the ith individual in the dataset \n\n\n\n\n\n","category":"method"},{"location":"plotting.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"We provide various functions to visualize the learnt latent trajectories, both for individual patients and panels of multiple patients, for both simulated data and SMArtCARE data.  We provide functions to plot the trajectories of the overall estimator of the solution and functions to plot the prediction from the model starting at the current time point until the next time point (the _piecewise functions).","category":"page"},{"location":"plotting.html#Simulated-data","page":"Plotting","title":"Simulated data","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"plot_truesolution","category":"page"},{"location":"plotting.html#Individual-trajectories","page":"Plotting","title":"Individual trajectories","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"createindividualplot(m::odevae, \n        data::simdata, \n        idx::Int, \n        sol::Matrix, \n        trange, \n        args::LossArgs;\n        title::String=\"\", \n        showtruesol::Bool=true,\n        axislabs::Bool=false, \n        showOLS::Bool=true, \n        colors_truesol::Array{String} = [\"#ff7f0e\" \"#1f77b4\"]\n)","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"createindividualplot_piecewise(m::odevae, \n        data::simdata, \n        ind::Int, \n        sol::Matrix, \n        t_range; \n        title::String=\"\", \n        axislabs::Bool=false, \n        showtruesol::Bool=true,\n        showOLS::Bool=true, \n        showglobalOLS::Bool=false,\n        colors_truesol::Array{String} = [\"#ff7f0e\" \"#1f77b4\"]\n)","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"eval_z_trajectories","category":"page"},{"location":"plotting.html#Panels-of-trajectories","page":"Plotting","title":"Panels of trajectories","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"plot_seleced_ids_piecewise(m::odevae, \n        data::simdata, \n        inds::Array{Int}, \n        sol_group1::Matrix, \n        sol_group2::Matrix, \n        t_range; \n        axislabs::Bool=false, \n        showtruesol::Bool=true,\n        showtitle::Bool=true, \n        showOLS::Bool=true, \n        showglobalOLS::Bool=false,\n        swapcolorcoding::Bool=false, \n        sort_inds::Bool=true\n    )","category":"page"},{"location":"plotting.html#SMArtCARE-data","page":"Plotting","title":"SMArtCARE data","text":"","category":"section"},{"location":"plotting.html#Individual-trajectories-2","page":"Plotting","title":"Individual trajectories","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"createindividualplot(m::odevae, \n        testdata::SMATestData, \n        args::LossArgs, \n        patient_id; \n        axislabs::Bool=false, \n        title::String=\"\", \n        showOLS::Bool=true\n)","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"createindividualplot_piecewise(m::odevae, \n        testdata::SMATestData, \n        patient_id; \n        title::String=\"\", \n        showOLS::Bool=true, \n        axislabs::Bool=false\n)","category":"page"},{"location":"plotting.html#Panels-of-trajectories-2","page":"Plotting","title":"Panels of trajectories","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"plot_selected_ids","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"plot_selected_ids_piecewise(m::odevae, \n    testdata::SMATestData,\n    selected_ids::Array; \n    showOLS::Bool=true\n)","category":"page"},{"location":"index.html#LatentDynamics.jl","page":"Introduction","title":"LatentDynamics.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This is a Julia package for fitting dynamic models based on ODEs in the latent space of a VAE. Specifically, it implements a statistical approach based on ODEs, where each observation serves as the initial value to obtain multiple local ODE solutions. The solutions are combined into an inverse-variance weighted estimator of the underlying dynamics. This reduces dependence of the ODE solution on the initial condition and provide a more robust estimation of the underlying trajectory, particularly in settings with a high level of noicse.  The ODEs are solved in the latent space of a VAE model, to reflect the assumption of an underlying latent process driving the observed measurements, for which the dynamics shall be modeled. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This illustrates how this enables the use of ODEs in longitudinal clinical registries, specifically focusing on the scenario of a rare disease registry on patients with spinal muscular atrophy (SMA), where data is noisy and heterogeneous and only few and irregular time points are available per patients. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We use the characterization of patients at the baseline time point to infer individual-specific ODE parameters for personalized dynamics using an additional neural network. All model components are optimized simultaneously based on differentiable programming, such that a low-dimensional representation can be found that is specifically adapted to the underlying trajectories as described by the person-specific ODE systems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The package includes functions for defining and training the VAE with and ODE-based dynamic in latent space, including a wide range of customizable hyperparameters and options for controlling the training behavior. Different choices for the underlying ODE system with different numbers of parameters are available. Further, the package provides functions for visualizing the learned latent trajectories and evaluating prediction performance at subsequent time points, both in latent space and on the reconstructed data and in comparison to simpler baseline models. The package provides functions for loading and pre-processing data from the SMArtCARE registry on spinal muscular atrophy (SMA) patients, which is used as an example application in the corresponding manuscript. As this data is not publicly available, we additionally provide functions for simulating data with a similar structure. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"For details, please have a look at our preprint Hackenberg et al. (2023) A statistical approach to latent dynamic modeling with differential equations.","category":"page"},{"location":"index.html#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"data.md\", \n    \"dynamics.md\",\n    \"vae.md\", \n    \"plotting.md\", \n    \"evaluation.md\"\n]","category":"page"},{"location":"evaluation.html#Evaluation","page":"Evaluation","title":"Evaluation","text":"","category":"section"},{"location":"evaluation.html#Simulated-data","page":"Evaluation","title":"Simulated data","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"eval_prediction(m::odevae, data::simdata, n_future_tps::Int=1)","category":"page"},{"location":"evaluation.html#LatentDynamics.eval_prediction","page":"Evaluation","title":"LatentDynamics.eval_prediction","text":"eval_prediction(m::odevae, data::simdata, n_future_tps::Int=1)\n\nEvaluate the prediction performance of the model on the latent representations. \n\nArguments\n\nm::odevae: trained odevae model\ntestdata: simdata object containing the simulated data\nn_future_tps::Int=1: number of future time points to predict\n\nReturns\n\nVectors of prediction errors of different models for each patient (summed over all time points):\n\nODEprederrs: vector of prediction errors for the ODE model\nOLSprederrs: vector of prediction errors for an OLS model, also fitted in a piecewise manner   similar to the ODE model\ninterceptprederrs: vector of prediction errors of an intercept model\nlocfprederrs: vector of prediction errors of a LOCF model\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"eval_reconstructed_prediction(m::odevae, data::simdata, n_future_tps::Int=1)","category":"page"},{"location":"evaluation.html#LatentDynamics.eval_reconstructed_prediction","page":"Evaluation","title":"LatentDynamics.eval_reconstructed_prediction","text":"eval_reconstructed_prediction(m::odevae, testdata::SMATestData, n_future_tps::Int=1)\n\nEvaluate the prediction performance of the model using the reconstructed data obtained from the decoder,  based on simulated data. \n\nArguments\n\nm::odevae: trained odevae model\ntestdata: simdata object containing the simulated data\nn_future_tps::Int=1: number of future time points to predict\n\nReturns\n\nVectors of prediction errors of different models for each patient (summed over all time points):\n\nODEprederrs: vector of prediction errors for the ODE model\nOLSprederrs: vector of prediction errors for an OLS model, also fitted in a piecewise manner   similar to the ODE model\ninterceptprederrs: vector of prediction errors of an intercept model\nlocfprederrs: vector of prediction errors of a LOCF model\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html#SMArtCARE-data","page":"Evaluation","title":"SMArtCARE data","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"eval_prediction(m::odevae, testdata::SMATestData, n_future_tps::Int=1)","category":"page"},{"location":"evaluation.html#LatentDynamics.eval_prediction-2","page":"Evaluation","title":"LatentDynamics.eval_prediction","text":"eval_prediction(m::odevae, testdata::SMATestData, n_future_tps::Int=1)\n\nEvaluate the prediction performance of the model on the latent representations. \n\nArguments\n\nm::odevae: trained odevae model\ntestdata: SMATestData object containing the SMArtCARE data\nn_future_tps::Int=1: number of future time points to predict\n\nReturns\n\nVectors of prediction errors of different models for each patient (summed over all time points):\n\nODEprederrs: vector of prediction errors for the ODE model\nOLSprederrs: vector of prediction errors for an OLS model, also fitted in a piecewise manner   similar to the ODE model\ninterceptprederrs: vector of prediction errors of an intercept model\nlocfprederrs: vector of prediction errors of a LOCF model\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"eval_reconstructed_prediction(m::odevae, testdata::SMATestData, n_future_tps::Int=1)","category":"page"},{"location":"evaluation.html#LatentDynamics.eval_reconstructed_prediction-2","page":"Evaluation","title":"LatentDynamics.eval_reconstructed_prediction","text":"eval_reconstructed_prediction(m::odevae, testdata::SMATestData, n_future_tps::Int=1)\n\nEvaluate the prediction performance of the model using the reconstructed data obtained from the decoder. \n\nArguments\n\nm::odevae: trained odevae model\ntestdata: SMATestData object containing the SMArtCARE data\nn_future_tps::Int=1: number of future time points to predict\n\nReturns\n\nVectors of prediction errors of different models for each patient (summed over all time points):\n\nODEprederrs: vector of prediction errors for the ODE model\nOLSprederrs: vector of prediction errors for an OLS model, also fitted in a piecewise manner   similar to the ODE model\ninterceptprederrs: vector of prediction errors of an intercept model\nlocfprederrs: vector of prediction errors of a LOCF model\n\n\n\n\n\n","category":"function"}]
}
